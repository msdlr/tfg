pragma solidity >=0.4.22 <0.7.0;

contract AUTH {
// <editor-fold defaultstate="collapsed" desc="Structs">
    struct User {
        address uAddr; // Used for checking a null user
        bool uLoggedIn;
        bool isAdmin;
    }

    struct OTP {
        User user;
        string pass;
        uint256 timestamp;
        bool isUsed;
        bool isExpired;
    }
// </editor-fold>

// <editor-fold defaultstate="collapsed" desc="State variables">
    mapping ( address => User) userList;
    mapping ( address => OTP) otpList;
    address master;

    // The approximate time for the OTPs to expire
    uint constant  OTPtimeout = 5 minutes;

// </editor-fold>

// <editor-fold defaultstate="collapsed" desc="Events">
    event createAdmin(address _adm, address _who, uint256 t);
// </editor-fold>

// <editor-fold defaultstate="collapsed" desc="Modifiers">

    modifier isUser() {
        require(userList[msg.sender].uAddr != address(0), "This user is not in the system.");
        _;
    }

    modifier isAdmin() {
        require(userList[msg.sender].uAddr != address(0), "This user is not in the system.");
        require(userList[msg.sender].isAdmin, "This user does not have admin. priviledges.");
        _;
    }

    modifier unusedOTP(){
        // The OTP can only be used once
        require(otpList[msg.sender].isUsed == false, "OTP is already used");
        _;
    }
// </editor-fold>

// <editor-fold defaultstate="collapsed" desc="Constructor">

    constructor(address _masterAcc) public payable{
        // Called by the master account
        master = msg.sender;

        // Stablish the parameter address as the first admin
        userList[_masterAcc].uAddr = msg.sender;
        userList[_masterAcc].isAdmin = true;
    }
// </editor-fold>

// <editor-fold defaultstate="collapsed" desc="Admin functions">
    function rmUser(address _addr) public isAdmin {
        userList[_addr].uAddr = address(0);
        userList[_addr].isAdmin = false;
    }

    function addUser(address _addr) public isAdmin {
        userList[_addr].uAddr = address(0);
        userList[_addr].isAdmin = false;
    }

    function addAdmin(address _addr) public isAdmin {
        // Check that the user is added
        require(userList[_addr].uAddr != address (0),"User does not exist.");
        // We update the user's profile with admin status
        userList[_addr].isAdmin = true;
        // We notify in the blockchain who did it
        emit createAdmin(_addr, msg.sender, now);
    }
// </editor-fold>

// <editor-fold defaultstate="collapsed" desc="User functions">
    function userLoggedIn(address _addr) public view isUser returns (bool b){
        if(userList[_addr].isAdmin){
            // Admins can check for every user
            return (userList[_addr].uLoggedIn);
        }
        else {
            // Users cannot check for other users
            require(userList[_addr].uAddr == msg.sender,"You can only check yourself.");
            return userList[msg.sender].uLoggedIn;
        }
    }
// </editor-fold>

// <editor-fold defaultstate="collapsed" desc="OTP functions">
    // Generate the OTP, without storing anything
    // This is to be called by web3 to encrypt the return
    function genOTP() public pure returns(string memory ret){
        // Very long key
        return string("keccak256(block.blockhash(block.number-1))");
    }

    // This is to be called by web3 with the encrypted otp generated by genOTP
    function storeEncOTP() public isUser returns(string memory cOTP){
        // We fill the fields for the OTP, with the pass encrypted
        otpList[msg.sender].user = userList[msg.sender];
        otpList[msg.sender].timestamp = block.timestamp;
        otpList[msg.sender].pass = cOTP;
        otpList[msg.sender].isUsed = false;
        otpList[msg.sender].isExpired = false;
    }

    // This is the encrypted pass and time remaining
    function getEncOTP() public isUser view returns
    (string memory cOTP_2string, uint aproxTime){
        // Apply marshalling to struct for gas usage
        // And an aproximate remaining time
        // Returns negative value if expored
        aproxTime = (now + OTPtimeout - otpList[msg.sender].timestamp);
        return (otpList[msg.sender].pass, aproxTime);
    }

    function checkOTPexpired(address _addr) private view returns(bool b) {
        // Returns if the OTP has expired
        return (now < (OTPtimeout + otpList[msg.sender].timestamp));
    }
// </editor-fold>

}